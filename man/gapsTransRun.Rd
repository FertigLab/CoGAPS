% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gapsTransRun.R
\name{gapsTransRun}
\alias{gapsTransRun}
\title{\code{gapsTransRun} calls the C++ MCMC code and performs Bayesian
matrix factorization returning the two matrices that reconstruct
the data matrix. This method also fits a logistic growth with ABC}
\usage{
gapsTransRun(D, S, nFactor, theta, FP, ABins = data.frame(),
  PBins = data.frame(), simulation_id = "simulation", nEquil = 1000,
  nSample = 1000, nOutR = 1000, output_atomic = FALSE,
  fixedMatrix = "P", fixedBinProbs = FALSE, fixedDomain = "N",
  sampleSnapshots = TRUE, numSnapshots = 100, alphaA = 0.01,
  nMaxA = 1e+05, max_gibbmass_paraA = 100, alphaP = 0.01, nMaxP = 1e+05,
  max_gibbmass_paraP = 100, growth.trans = "logistic",
  time.of.sample = 1:ncol(D), condition = rep(0, ncol(D)), thin = 1,
  delta = 0.01, prior.mean = 0, prior.sd = 10, epsilon = 1)
}
\arguments{
\item{D}{data matrix}

\item{S}{uncertainty matrix (std devs for chi-squared of Log Likelihood)}

\item{nFactor}{number of patterns (basis vectors, metagenes), which must be
greater than or equal to the number of rows of FP}

\item{ABins}{a matrix of same size as A which gives relative
probability of that element being non-zero}

\item{PBins}{a matrix of same size as P which gives relative
probability of that element being non-zero}

\item{simulation_id}{name to attach to atoms files if created}

\item{nEquil}{number of iterations for burn-in}

\item{nSample}{number of iterations for sampling}

\item{nOutR}{how often to print status into R by iterations}

\item{output_atomic}{whether to write atom files (large)}

\item{fixedBinProbs}{Boolean for using relative probabilities
given in Abins and Pbins}

\item{fixedDomain}{character to indicate whether A or P is
domain for relative probabilities}

\item{sampleSnapshots}{Boolean to indicate whether to capture
individual samples from Markov chain during sampling}

\item{numSnapshots}{the number of individual samples to capture}

\item{alphaA}{sparsity parameter for A domain}

\item{nMaxA}{PRESENTLY UNUSED, future = limit number of atoms}

\item{max_gibbmass_paraA}{limit truncated normal to max size}

\item{alphaP}{sparsity parameter for P domain}

\item{nMaxP}{PRESENTLY UNUSED, future = limit number of atoms}

\item{max_gibbmass_paraP}{limit truncated normal to max size}

\item{growth.trans}{Growth function, currently unused}

\item{time.of.sample}{Time (z-normalized) of sample recording}

\item{condition}{Status of measurement (e.g. treated vs untreated). currently unused}

\item{thin}{Number of thinning intervals for ABC update}

\item{delta}{standard deviation of metropolis proposal distribution}

\item{prior.mean}{prior mean on ABC parameters}

\item{prior.sd}{prior sd on ABC parameters}

\item{epsilon}{Acceptance criteria for ABC}

\item{Initial}{value for logistic growth parameter}
}
\description{
\code{gapsTransRun} calls the C++ MCMC code and performs Bayesian
matrix factorization returning the two matrices that reconstruct
the data matrix. This method also fits a logistic growth with ABC
}
