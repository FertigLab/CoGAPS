---
title: "CoGAPS - Coordinated Gene Association in Pattern Sets"
author: "Genevieve Stein-O'Brien, Thomas Sherman, Hyejune Limb, Elana Fertig"
date: "`r doc_date()`"
bibliography: References.bib
vignette: >
    %\VignetteIndexEntry{CoGAPS}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
output: 
    BiocStyle::html_document
---

```{r include=FALSE, cache=FALSE}
library(CoGAPS)
```

# Introduction

Coordinated Gene Association in Pattern Sets (CoGAPS) infers underlying patterns
in a matrix of measurements that can be interpreted as arising from the
multiplication of two lower dimensional matrices. 

The Markov chain Monte Carlo (MCMC) matrix factorization that infers patterns
also infers the extent to which individual genes belong to these patterns. The
CoGAPS algorithm extends GAPS to infer the coordinated activity in sets of genes
for each of the inferred patterns based upon (5) and to refine gene set
membership based upon (2).

# Installing CoGAPS from Bioconductor

*CoGAPS* is a bioconductor package and so the release version can be installed
as follows:

```{r eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("CoGAPS")
```

The most up to date version of *CoGAPS* can be installed directly from the 
*FertigLab* Github Repository:

```{r eval=FALSE}
## Method 1 using devtools package
devtools::install_github("FertigLab/CoGAPS")

## Method 2 using biocLite
biocLite("FertigLab/CoGAPS", dependencies = TRUE, build_vignettes = TRUE)
```

# Running CoGAPS

Here we walkthrough running *CoGAPS* on the *GIST* data set from Ochs et
al. (2009), which contains gene expression data from gastrointestinal
stromal tumor cell lines treated with Gleevec. The matrix contains bulk gene
expression data with 1363 genes and 9 samples.

## Setting Parameters

The first step when running CoGAPS is to create a parameters object.

```{r}
# create new parameters object
params <- new("CogapsParams")
```

This object will store all parameters needed to run CoGAPS and provides a
simple interface for viewing and setting the parameter values.

```{r}
# view all parameters
params

# get the value for a specific parameter
getParam(params, "nPatterns")

# set the value for a specific parameter
params <- setParam(params, "nPatterns", 3)
getParam(params, "nPatterns")
``` 

## Calling CoGAPS

Once we've created the parameters object we can pass it along with our data to
the main function in *CoGAPS*.

```{r}
# load data
data(GIST)

# run CoGAPS
result <- CoGAPS(GIST.D, params)
```

## Visualizing Output

*CoGAPS* returns a *CogapsResult* object that can be passed on to the analysis
and plotting functions provided in the package.

By default, the *plot* function displays the patterns across samples.

```{r}
# plot CogapsResult object returned from CoGAPS
plot(result)
```

## Running CoGAPS in Parallel

*CoGAPS* can be run across multiple cores by setting the *nCores* parameter.
This is different from (Running Distributed CoGAPS)[running-distributed-cogaps].
The algorithm will run in the normal fashion, without splitting up the data.

```{r}
params <- setParam(params, "nCores", 4)
```

## Selecting Appropiate Number of Patterns

Selecting the best value for *nPatterns* is the most difficult part of the
analysis. For starters, there is not one "best" value for the number of
patterns - various numbers of patterns can capture various levels of
granularity in the data. To further complicate the problem, there's not a
clear way to compare runs for different numbers of patterns.

Here we show the simplest approach of selecting dimensionality by plotting the
error and selecting the least number of patterns that sufficiently reduce the
error. We also introduce another way to pass parameters - any parameter in the 
*CogapsParams* class can be passed by name directly to the *CoGAPS* function,
overwriting the value contained in `params`.

```{r}
# define the range of patterns we are searching over
pattern_range <- c(3,5,8)

# run CoGAPS with each value in range
resultList <- lapply(pattern_range, function(p) CoGAPS(GIST.D, params, nPatterns=p, nIterations=3000, outputFrequency=2500))

# plot chi-sq values for each run
chisq <- sapply(resultList, function(result) getMeanChiSq(result))
plot(pattern_range, chisq)
```

## Running CoGAPS on Single Cell Data

The size and distribution of single cell data creates additional considerations
when running *CoGAPS*. The section
[Running Distributed CoGAPS](#running-distributed-cogaps) gives an overview
for running CoGAPS on large single cell datasets. With regards to the 
distribution of single cell data, it is neccesary to set the parameter
**singleCell**, i.e. `params <- setParam(params, "singleCell" , TRUE)`.

## Altenative Data Formats

CoGAPS supports both R objects and file names as input. Any of these data types
can be passed directly to *CoGAPS* as the *data* parameter.

R object

* matrix
* data.frame
* SummarizedExperiment
* SingleCellExperiment

File

* .mtx
* .tsv
* .csv

## Passing Uncertainty Matrix

In addition to providing the data, the user can also specify an uncertainty
measurement - the standard deviation of each entry in the data matrix. By
default, *CoGAPS* assumes that the standard deviation matrix is 10% of the
data.

```{r}
# run CoGAPS with custom uncertainty
result <- CoGAPS(GIST.D, params, uncertainty=as.matrix(GIST.S))
```

# Running Distributed CoGAPS

For extremely large datasets (greater than a few thousand rows or columns), it
is much more efficient to break up the data into random subsets and perform
*CoGAPS* on each subset in parallel - stitching the results back together
at the end. The full explanation of this method can be seen here
 (CITE GWCOGAPS).

To run *CoGAPS* in this distributed way there are two distinct functions.
Genome-Wide CoGAPS - *GWCoGAPS* and Single Cell CoGAPS - *scCoGAPS*. 
*GWCoGAPS* is used to break the genes (rows) into subsets and *scCoGAPS* is
used to break the samples (columns - cells in single cell data) into subsets.
Both methods follow a similiar workflow and the underlying method is 
essentially the same.

The first step is breaking the data into subsets. This is done as a separate
step where all subsets are then saved back to a file. In the case where the
data set is so large it requires a machine with large memory, this allows the
user to only pay for the machine for enough time to split the data. The actual 
algorithm should use a reasonable amount of memory on each machine during
the distributed computation.

```{r}
# splitting data into subsets for GWCoGAPS
gw_sim_name <- createGWCoGAPSSets(as.matrix(GIST.D), as.matrix(GIST.S), nSets=4, "gw_example")

# splitting data into subsets for scCoGAPS
sc_sim_name <- createscCoGAPSSets(t(as.matrix(GIST.D)), nSets=4, "sc_example")
```

Notice that we pass the transpose of the *GIST* data to *scCoGAPS* since
the normal dataset is 1363 x 9 and we want a data set with a large number of
samples.

It is neccesary to name the simulation so that the computation portion knows
what the subset files are called. For convenience the name provided to the
subset function is returned back so that it can be saved.

Running the computation is just as easy as running normal *CoGAPS*. The results
will be in the exact same format as *CoGAPS*, only the intermediate computation
is different. Notice here that no *params* object is accepted - all parameters
must be passed by name.

```{r}
GWCoGAPS(gw_sim_name, nPatterns=3, nIterations=1000)
scCoGAPS(sc_sim_name, nPatterns=3, nIterations=1000)
```

# Using CoGAPS-based statistics to infer gene membership in annotated gene sets

## CoGAPSStat

The function *calcCoGAPSStat* is used to infer gene set activity in each
pattern from the CoGAPS matrix factorization. *calcCoGAPSStat* calculates the
gene set statistics for each column of the feature matrix using a Z-score, the
input gene set and permutation tests. The function outputs a list containing:

* *GSUpreg* lists p-values for upregulation of each gene set in each pattern
* *GSDownreg* lists p-values for downregulation of each gene set in each pattern
* *GSActEst* provides gene set activity through conversion of p-values to
activity estimates of each gene set in each pattern

## computeGeneGSProb

Now using the *computeGeneGSProb* function, we can use the gene set statistic
(returned from calcCoGAPSStat) to compute a statistic to quantify the
likelihood of membership for each gene annotated to a set based on its
inferred activity. The statistic used to infer membership compares the 
expression pattern of a gene annotated as a member of a gene set to the common
expression pattern of all annotated members of that gene set. The function
outputs the p-value of a set membership for each gene specified in GStoGenes. 

# Citing CoGAPS

If you use the CoGAPS package for your analysis please cite: (1) EJ Fertig,
J Ding, AV Favorov, G Parmigiani, and MF Ochs (2010) CoGAPS: an R/C++ package to
identify patterns and biological process activity in transcriptomic data.
Bioinformatics 26: 2792-2793.

To cite the CoGAPS algorithm use: (3) MF Ochs (2003) Bayesian Decomposition in
The Analysis of Gene Expression Data: Methods and Software G Parmigiani,
E Garrett, R Irizarry, and S Zeger, ed. New York: Springer Verlag.

To cite the gene set statistic use: (5) MF Ochs, L Rink, C Tarn, S Mburu,
T Taguchi, B Eisenberg, and AK Godwin (2009) Detection of treatment-induced
changes in signaling pathways in gastrointestinal stromal tumors using
transcriptomic data. Cancer Research 69: 9125-9132.

To site the set-membership refinement statistic use: (2) EJ Fertig, AV Favorov,
and MF Ochs (2012) Identifying context-specific transcription factor targets
from prior knowledge and gene expression data. 2012 IEEE International
Conference on Bioinformatics and Biomedicine, B310, in press.

# References
