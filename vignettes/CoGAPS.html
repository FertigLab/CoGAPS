<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Vignette Version</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Vignette Version</h1>

<p>This vignette was built using CoGAPS version:</p>

<pre><code class="r">packageVersion(&quot;CoGAPS&quot;)
</code></pre>

<pre><code>## [1] &#39;3.5.3&#39;
</code></pre>

<h1>Introduction</h1>

<p>Coordinated Gene Association in Pattern Sets (CoGAPS) is a technique for latent
space learning in gene expression data. CoGAPS is a member of the
Nonnegative Matrix Factorization (NMF) class of algorithms. NMFs factorize a
data matrix into two related matrices containing gene weights, the
Amplitude (A) matrix, and sample weights, the Pattern (P) Matrix. Each column
of A or row of P defines a feature and together this set of features defines
the latent space among genes and samples, respectively. In NMF, the values of
the elements in the A and P matrices are constrained to be greater than or
equal to zero. This constraint simultaneously reflects the non-negative nature
of gene expression data and enforces the additive nature of the resulting
feature dimensions, generating solutions that are biologically intuitive to
interpret (@SEUNG_1999).</p>

<p>CoGAPS has two extensions that allow it to scale up to large data sets,
Genome-Wide CoGAPS (GWCoGAPS) and Single-Cell CoGAPS (scCOGAPS). This package
presents a unified R interface for all three methods, with a parallel,
efficient underlying implementation in C++.</p>

<h1>Installing CoGAPS</h1>

<p><em>CoGAPS</em> is a bioconductor package and so the release version can be installed
as follows:</p>

<pre><code class="r">source(&quot;https://bioconductor.org/biocLite.R&quot;)
biocLite(&quot;CoGAPS&quot;)
</code></pre>

<p>The most up-to-date version of <em>CoGAPS</em> can be installed directly from the 
<em>FertigLab</em> Github Repository:</p>

<pre><code class="r">## Method 1 using biocLite
biocLite(&quot;FertigLab/CoGAPS&quot;, dependencies = TRUE, build_vignettes = TRUE)

## Method 2 using devtools package
devtools::install_github(&quot;FertigLab/CoGAPS&quot;)
</code></pre>

<p>There is also an option to install the development version of <em>CoGAPS</em>, 
while this version has the latest experimental features, it is not guaranteed
to be stable.</p>

<pre><code class="r">## Method 1 using biocLite
biocLite(&quot;FertigLab/CoGAPS&quot;, ref=&quot;develop&quot;, dependencies = TRUE, build_vignettes = TRUE)

## Method 2 using devtools package
devtools::install_github(&quot;FertigLab/CoGAPS&quot;, ref=&quot;develop&quot;)
</code></pre>

<h1>Package Overview</h1>

<p>We first give a walkthrough of the package features using a simple, simulated
data set. In later sections we provide two example workflows on real data
sets.</p>

<h2>Running CoGAPS with Default Parameters</h2>

<p>The only required argument to <code>CoGAPS</code> is the data set. This can be a <code>matrix</code>,
<code>data.frame</code>, <code>SummarizedExperiment</code>, <code>SingleCellExperiment</code> or the path of a
file (<code>tsv</code>, <code>csv</code>, <code>mtx</code>, <code>gct</code>) containing the data.</p>

<pre><code class="r"># load data
data(GIST)

# run CoGAPS
CoGAPS(GIST.matrix)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples) with parameters:
## 
## -- Standard Parameters --
## nPatterns            7 
## nIterations          2000 
## seed                 979 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;7 patterns were learned&quot;
</code></pre>

<p>While CoGAPS is running it periodically prints status messages. For example,
<code>20000 of 25000, Atoms: 2932(80), ChiSq: 9728, time: 00:00:29 / 00:01:19</code>. This
message tells us that CoGAPS is at iteration 20000 out of 25000 for this phase,
and that 29 seconds out of an estimated 1 minute 19 seconds have passed. It 
also tells us the size of the atomic domain which is a core component of the 
algorithm but can be ignored for now. Finally, the ChiSq value tells us how
closely the A and P matrices reconstruct the original data. In general, we want
this value to go down - but it is not a perfect measurment of how well CoGAPS
is finding the biological processes contained in the data. CoGAPS also prints
a message indicating which phase is currently happening. There are two phases
to the algorithm - <em>Equilibration</em> and <em>Sampling</em>.</p>

<h2>Setting Parameters</h2>

<h3>Model Parameters</h3>

<p>Most of the time we&#39;ll want to set some parameters before running CoGAPS.
Parameters are managed with a <code>CogapsParams</code> object. This object will
store all parameters needed to run CoGAPS and provides a simple interface for
viewing and setting the parameter values.</p>

<pre><code class="r"># create new parameters object
params &lt;- new(&quot;CogapsParams&quot;)

# view all parameters
params
</code></pre>

<pre><code>## -- Standard Parameters --
## nPatterns            7 
## nIterations          2000 
## seed                 204 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<pre><code class="r"># get the value for a specific parameter
getParam(params, &quot;nPatterns&quot;)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r"># set the value for a specific parameter
params &lt;- setParam(params, &quot;nPatterns&quot;, 3)
getParam(params, &quot;nPatterns&quot;)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<p>Once we&#39;ve created the parameters object we can pass it along with our data to
<code>CoGAPS</code>.</p>

<pre><code class="r"># run CoGAPS with specified model parameters
CoGAPS(GIST.matrix, params)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples) with parameters:
## 
## -- Standard Parameters --
## nPatterns            3 
## nIterations          2000 
## seed                 204 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<h3>Run Configuration Options</h3>

<p>The <code>CogapsParams</code> class manages the model parameters - i.e. the parameters
that affect the result. There are also a few parameters that are passed
directly to <code>CoGAPS</code> that control things like displaying the status of the run.</p>

<pre><code class="r"># run CoGAPS with specified output frequency
CoGAPS(GIST.matrix, params, outputFrequency=250)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples) with parameters:
## 
## -- Standard Parameters --
## nPatterns            3 
## nIterations          2000 
## seed                 204 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<p>There are several other arguments that are passed directly to <code>CoGAPS</code> which
are covered in later sections.</p>

<h2>Breaking Down the Return Object from CoGAPS</h2>

<p>CoGAPS returns a object of the class <code>CogapsResult</code> which inherits from <code>LinearEmbeddingMatrix</code> (defined in the <code>SingleCellExperiment</code>
package). CoGAPS stores the lower dimensional representation of the samples 
(P matrix) in the <code>sampleFactors</code> slot and the weight of the features (A matrix)
in the <code>featureLoadings</code> slot. <code>CogapsResult</code> also adds two of its own slots -
<code>sampleStdDev</code> and <code>featureStdDev</code> which contain the standard deviation across
sample points for each matrix.</p>

<p>There is also some information in the <code>metadata</code> slot such as the original
parameters and value for the Chi-Sq statistic. In general, the metadata will
vary depending on how <code>CoGAPS</code> was called in the first place. The package 
provides these functions for querying the metadata in a safe manner:</p>

<pre><code class="r"># run CoGAPS
result &lt;- CoGAPS(GIST.matrix, params, messages=FALSE)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples)
</code></pre>

<pre><code class="r"># get the mean ChiSq statistic over all samples
getMeanChiSq(result)
</code></pre>

<pre><code>## [1] 4345.261
</code></pre>

<pre><code class="r"># get the version number used to create this result
getVersion(result)
</code></pre>

<pre><code>## [1] &#39;3.5.3&#39;
</code></pre>

<pre><code class="r"># get the original parameters used to create this result
getOriginalParameters(result)
</code></pre>

<pre><code>## -- Standard Parameters --
## nPatterns            3 
## nIterations          2000 
## seed                 204 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<p>To convert a <code>CogapsResult</code> object to a <code>LinearEmbeddingMatrix</code> use</p>

<pre><code class="r">as(result, &quot;LinearEmbeddingMatrix&quot;)
</code></pre>

<pre><code>## class: LinearEmbeddingMatrix 
## dim: 9 3 
## metadata(12): meanChiSq chisq ... params version
## rownames: NULL
## colnames: NULL
## factorData names(0):
</code></pre>

<h2>Visualizing Output</h2>

<p>The <code>CogapsResult</code> object can be passed on to the analysis
and plotting functions provided in the package. By default, the <code>plot</code> function
displays how the patterns vary across the samples. (Note that we pass the 
<code>nIterations</code> parameter here directly, this is allowed for any parameters in 
the <code>CogapsParams</code> class and will always take precedent over the values given
in <code>params</code>).</p>

<pre><code class="r"># store result
result &lt;- CoGAPS(GIST.matrix, params, nIterations=5000, messages=FALSE)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples)
</code></pre>

<pre><code class="r"># plot CogapsResult object returned from CoGAPS
plot(result)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-12"/></p>

<p>In the example workflows we&#39;ll explore some more analysis functions provided in
the package.</p>

<h2>Running CoGAPS in Parallel</h2>

<p>Non-Negative Matrix Factorization algorithms typically require long computation
times and CoGAPS is no exception. In order to scale CoGAPS up to the size of
data sets seen in practice we need to take advantage of modern hardware
and parallelize the algorithm.</p>

<h3>Multi-Threaded Parallelization</h3>

<p>The simplest way to run CoGAPS in parallel is to provide the <code>nThreads</code>
argument to <code>CoGAPS</code>. This allows the underlying algorithm to run on multiple
threads and has no effect on the mathematics of the algorithm i.e. this is
still standard CoGAPS. The precise number of threads to use depends on many
things like hardware and data size. The best approach is to play around with
different values and see how it effects the estimated time.</p>

<pre><code class="r">CoGAPS(GIST.matrix, nIterations=10000, outputFrequency=5000, nThreads=1, seed=5)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples) with parameters:
## 
## -- Standard Parameters --
## nPatterns            7 
## nIterations          10000 
## seed                 5 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;7 patterns were learned&quot;
</code></pre>

<pre><code class="r">CoGAPS(GIST.matrix, nIterations=10000, outputFrequency=5000, nThreads=4, seed=5)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples) with parameters:
## 
## -- Standard Parameters --
## nPatterns            7 
## nIterations          10000 
## seed                 5 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;7 patterns were learned&quot;
</code></pre>

<p>Note this method relies on CoGAPS being compiled with OpenMP support, use
<code>buildReport</code> to check.</p>

<pre><code class="r">cat(CoGAPS::buildReport())
</code></pre>

<pre><code>## Compiled with Clang
## SIMD: AVX instructions enabled
## Compiled with OpenMP
</code></pre>

<h3>Distributed CoGAPS (GWCoGAPS/scCoGAPS)</h3>

<p>For large datasets (greater than a few thousand genes or samples) the
multi-threaded parallelization isn&#39;t enough. It is more efficient to break up
the data into subsets and perform CoGAPS on each subset in parallel, stitching 
the results back together at the end. The CoGAPS extensions, GWCOGAPS and 
scCoGAPS, each implement a version of this method (@OBRIEN_2017).</p>

<p>In order to use these extensions, some additional parameters are required.
<code>nSets</code> specifies the number of subsets to break the data set into. <code>cut</code>,
<code>minNS</code>, and <code>maxNS</code> control the process of matching patterns across subsets
and in general should not be changed from defaults. More information about
these parameters can be found in the original papers. These parameters
need to be set with a different function than <code>setParam</code> since they depend
on each other. Here we only set <code>nSets</code> (always required), but we have the
option to pass the other parameters as well.</p>

<pre><code class="r">params &lt;- setDistributedParams(params, nSets=3)
</code></pre>

<pre><code>## setting distributed parameters - call this again if you change nPatterns
</code></pre>

<p>Setting <code>nSets</code> requires balancing available hardware and run time against the
size of your data. In general, <code>nSets</code> should be less than or equal to the
number of nodes/cores that are available. If that is true, then the more subsets
you create, the faster CoGAPS will run - however, some robustness can be lost
when the subsets get too small. The general rule of thumb is to set <code>nSets</code>
so that each subset has between 1000 and 5000 genes or cells. We will see an
example of this on real data in the next two sections.</p>

<p>Once the distributed parameters have been set we can call CoGAPS either by
setting the <code>distributed</code> parameter or by using the provided wrapper functions.
The following calls are equivalent:</p>

<pre><code class="r"># need to use a file with distributed cogaps
GISTCsvPath &lt;- system.file(&quot;extdata/GIST.csv&quot;, package=&quot;CoGAPS&quot;)

# genome-wide CoGAPS
GWCoGAPS(GISTCsvPath, params, messages=FALSE)
</code></pre>

<pre><code>## Warning in GWCoGAPS(GISTCsvPath, params, messages = FALSE): GWCoGAPS
## is deprecated, use the main function CoGAPS with the argument:
## distributed=&quot;genome-wide&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples)
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<pre><code class="r"># genome-wide CoGAPS
CoGAPS(GISTCsvPath, params, distributed=&quot;genome-wide&quot;, messages=FALSE)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples)
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<pre><code class="r"># single-cell CoGAPS
scCoGAPS(GISTCsvPath, params, messages=FALSE, transposeData=TRUE)
</code></pre>

<pre><code>## Warning in scCoGAPS(GISTCsvPath, params, messages = FALSE, transposeData
## = TRUE): scCoGAPS is deprecated, use the main function CoGAPS with the
## argument: distributed=&quot;single-cell&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running single-cell CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (9 genes and 1363 samples)
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 9 features and 1363 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<pre><code class="r"># single-cell CoGAPS
CoGAPS(GISTCsvPath, params, distributed=&quot;single-cell&quot;, singleCell=TRUE, messages=FALSE, transposeData=TRUE)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running single-cell CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (9 genes and 1363 samples)
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 9 features and 1363 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<p>Notice that we also set the parameter <code>singleCell=TRUE</code>. This makes some 
adjustments to the algorithm to account for the sparsity in single-cell data.
The <code>scCoGAPS</code> wrapper automatically sets this parameter for us.</p>

<p>The parallel backend for this computation is managed by the package <code>BiocParallel</code>
and there is an option for the user to specifiy which backend they want. See the
<a href="#setting-parallel-backend">Additional Features</a>
section for more information.</p>

<p>In general it is preferred to pass a file name to <code>GWCoGAPS</code>/<code>scCoGAPS</code> since
otherwise the entire data set must be copied across multiple processes which
will slow things down and potentially cause an out-of-memory error. We will
see examples of this in the next two sections.</p>

<h1>Additional Features of CoGAPS</h1>

<h2>Checkpoint System - Saving/Loading CoGAPS Runs</h2>

<p>CoGAPS allows the user to save their progress throughout the run, and restart
from the latest saved &ldquo;checkpoint&rdquo;. This is intended so that if the server
crashes in the middle of a long run it doesn&#39;t need to be restarted from the
beginning. Set the <code>checkpointInterval</code> parameter to save checkpoints and
pass a file name as <code>checkpointInFile</code> to load from a checkpoint. </p>

<pre><code class="r">if (CoGAPS::checkpointsEnabled())
{
    # our initial run
    res1 &lt;- CoGAPS(GIST.matrix, params, checkpointInterval=100, checkpointOutFile=&quot;vignette_example.out&quot;, messages=FALSE)

    # assume the previous run crashes
    res2 &lt;- CoGAPS(GIST.matrix, checkpointInFile=&quot;vignette_example.out&quot;, messages=FALSE)

    # check that they&#39;re equal
    all(res1@featureLoadings == res2@featureLoadings)
    all(res1@sampleFactors == res2@sampleFactors)
}
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples)
## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h2>Transposing Data</h2>

<p>If your data is stored as samples x genes, <code>CoGAPS</code> allows you to pass
<code>transposeData=TRUE</code> and will automatically read the transpose of your data
to get the required genes x samples configuration.</p>

<h2>Passing Uncertainty Matrix</h2>

<p>In addition to providing the data, the user can also specify an uncertainty
measurement - the standard deviation of each entry in the data matrix. By
default, <code>CoGAPS</code> assumes that the standard deviation matrix is 10% of the
data matrix. This is a reasonable heuristic to use, but for specific types
of data you may be able to provide better information.</p>

<pre><code class="r"># run CoGAPS with custom uncertainty
data(GIST)
result &lt;- CoGAPS(GIST.matrix, params, uncertainty=GIST.uncertainty, messages=FALSE)
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running Standard CoGAPS on GIST.matrix (1363 genes and 9 samples)
</code></pre>

<h2>GWCoGAPS/scCoGAPS</h2>

<h3>Setting Parallel Backend</h3>

<p>The distributed computation for CoGAPS uses <code>BiocParallel</code> underneath the hood
to manage the parallelization. The user has the option to specify what the
backend should be. By default, it is <code>MulticoreParam</code> with the same number
of workers as <code>nSets</code>. Use the <code>BPPARAM</code> parameter in <code>CoGAPS</code> to set the
backend. See the vignette for <code>BiocParallel</code> for more information about the
different choices for the backend.</p>

<pre><code class="r"># run CoGAPS with serial backend
scCoGAPS(GISTCsvPath, params, BPPARAM=BiocParallel::SerialParam(), messages=FALSE, transposeData=TRUE)
</code></pre>

<pre><code>## Warning in scCoGAPS(GISTCsvPath, params, BPPARAM =
## BiocParallel::SerialParam(), : scCoGAPS is deprecated, use the main
## function CoGAPS with the argument: distributed=&quot;single-cell&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running single-cell CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (9 genes and 1363 samples)
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 9 features and 1363 samples&quot;
## [1] &quot;3 patterns were learned&quot;
</code></pre>

<h3>Methods of Subsetting Data</h3>

<p>The default method for subsetting the data is to uniformly break up the rows
(cols) of the data. There is an alternative option where the user provides an
annotation vector for the rownames (colnames) of the data and gives a weight to
each category in the annotation vector. Equal sized subsets are then drawn by 
sampling all rows (cols) according to the weight of each category.</p>

<pre><code class="r"># sampling with weights
anno &lt;- sample(letters[1:5], size=nrow(GIST.matrix), replace=TRUE)
w &lt;- c(1,1,2,2,1)
names(w) &lt;- letters[1:5]
params &lt;- new(&quot;CogapsParams&quot;)
params &lt;- setAnnotationWeights(params, annotation=anno, weights=w)
result &lt;- GWCoGAPS(GISTCsvPath, params, messages=FALSE)
</code></pre>

<pre><code>## Warning in GWCoGAPS(GISTCsvPath, params, messages = FALSE): GWCoGAPS
## is deprecated, use the main function CoGAPS with the argument:
## distributed=&quot;genome-wide&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples)
</code></pre>

<p>Finally, the user can set <code>explicitSets</code> which is a list of character or 
numeric vectors indicating which names or indices of the data should be put
into each set. Make sure to set <code>nSets</code> to the correct value before passing <code>explicitSets</code>.</p>

<pre><code class="r"># running cogaps with given subsets
sets &lt;- list(1:225, 226:450, 451:675, 676:900)
params &lt;- new(&quot;CogapsParams&quot;)
params &lt;- setDistributedParams(params, nSets=length(sets))
</code></pre>

<pre><code>## setting distributed parameters - call this again if you change nPatterns
</code></pre>

<pre><code class="r">result &lt;- GWCoGAPS(GISTCsvPath, params, explicitSets=sets, messages=FALSE)
</code></pre>

<pre><code>## Warning in GWCoGAPS(GISTCsvPath, params, explicitSets = sets, messages
## = FALSE): GWCoGAPS is deprecated, use the main function CoGAPS with the
## argument: distributed=&quot;genome-wide&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples)
</code></pre>

<h3>Additional Return Information</h3>

<p>When running GWCoGAPS or scCoGAPS, some additional metadata is returned that 
relates to the pattern matching process. This process is how CoGAPS
stitches the results from each subset back together.</p>

<pre><code class="r"># run GWCoGAPS (subset data so the displayed output is small)
params &lt;- new(&quot;CogapsParams&quot;)
params &lt;- setParam(params, &quot;nPatterns&quot;, 3)
params &lt;- setDistributedParams(params, nSets=2)
</code></pre>

<pre><code>## setting distributed parameters - call this again if you change nPatterns
</code></pre>

<pre><code class="r">result &lt;- GWCoGAPS(GISTCsvPath, params, messages=FALSE)
</code></pre>

<pre><code>## Warning in GWCoGAPS(GISTCsvPath, params, messages = FALSE): GWCoGAPS
## is deprecated, use the main function CoGAPS with the argument:
## distributed=&quot;genome-wide&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples)
</code></pre>

<pre><code class="r"># get the unmatched patterns from each subset
getUnmatchedPatterns(result)
</code></pre>

<pre><code>## [[1]]
##      Pattern_1 Pattern_2 Pattern_3
## IM00 0.8191165 0.9998286 0.9972035
## IM02 0.8425168 0.9705399 0.9915565
## IM04 0.8684474 0.9266143 0.9617928
## IM06 0.8902925 0.9177760 0.9700505
## IM09 0.9161828 0.8779119 0.9612342
## IM12 0.9472376 0.8557693 0.9813614
## IM18 0.9740070 0.8266732 0.9791477
## IM24 0.9994053 0.7606136 0.9733939
## IM48 0.9841462 0.7508671 0.9819213
## 
## [[2]]
##      Pattern_1 Pattern_2 Pattern_3
## IM00 0.9898956 0.9984570 0.8924408
## IM02 0.9903753 0.9779490 0.9043376
## IM04 0.9701636 0.9298828 0.9121473
## IM06 0.9763661 0.9141088 0.9301310
## IM09 0.9711767 0.8542769 0.9442629
## IM12 0.9926066 0.8155822 0.9682058
## IM18 0.9913293 0.7693400 0.9829336
## IM24 0.9788853 0.7246498 0.9978984
## IM48 0.9832644 0.7243645 0.9917265
</code></pre>

<pre><code class="r"># get the clustered patterns from the set of all patterns
getClusteredPatterns(result)
</code></pre>

<pre><code>## $`1`
##            1.1       2.3
## IM00 0.8191165 0.8924408
## IM02 0.8425168 0.9043376
## IM04 0.8684474 0.9121473
## IM06 0.8902925 0.9301310
## IM09 0.9161828 0.9442629
## IM12 0.9472376 0.9682058
## IM18 0.9740070 0.9829336
## IM24 0.9994053 0.9978984
## IM48 0.9841462 0.9917265
## 
## $`2`
##            2.1       1.3
## IM00 0.9998286 0.9984570
## IM02 0.9705399 0.9779490
## IM04 0.9266143 0.9298828
## IM06 0.9177760 0.9141088
## IM09 0.8779119 0.8542769
## IM12 0.8557693 0.8155822
## IM18 0.8266732 0.7693400
## IM24 0.7606136 0.7246498
## IM48 0.7508671 0.7243645
## 
## $`3`
##            1.2       2.2
## IM00 0.9972035 0.9898956
## IM02 0.9915565 0.9903753
## IM04 0.9617928 0.9701636
## IM06 0.9700505 0.9763661
## IM09 0.9612342 0.9711767
## IM12 0.9813614 0.9926066
## IM18 0.9791477 0.9913293
## IM24 0.9733939 0.9788853
## IM48 0.9819213 0.9832644
</code></pre>

<pre><code class="r"># get the correlation of each pattern to the cluster mean
getCorrelationToMeanPattern(result)
</code></pre>

<pre><code>## $`1`
## [1] 1.000 0.999
## 
## $`2`
## [1] 0.997 0.998
## 
## $`3`
## [1] 0.976 0.953
</code></pre>

<pre><code class="r"># get the size of the subsets used
sapply(getSubsets(result), length)
</code></pre>

<pre><code>## [1] 681 682
</code></pre>

<h3>Manual Pipeline</h3>

<p>CoGAPS allows for a custom process for matching the patterns together. If you 
have a result object from a previous run of GWCoGAPS/scCoGAPS, the unmatched
patterns for each subset are found by calling <code>getUnmatchedPatterns</code>. Apply
any method you like as long as the result is a matrix with the number of rows
equal to the number of samples (genes) and the number of columns is equal to 
the number of patterns. Then pass the matrix to the  <code>fixedPatterns</code> argument
along with the original parameters for the GWCoGAPS/scCoGAPS run.</p>

<pre><code class="r"># initial run
result &lt;- GWCoGAPS(GISTCsvPath, messages=FALSE)
</code></pre>

<pre><code>## Warning in GWCoGAPS(GISTCsvPath, messages = FALSE): GWCoGAPS is deprecated,
## use the main function CoGAPS with the argument: distributed=&quot;genome-wide&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples)
</code></pre>

<pre><code class="r"># custom matching process (just take matrix from first subset as a dummy)
consensusMatrix &lt;- getUnmatchedPatterns(result)[[1]]

# run with our custom matched patterns matrix
params &lt;- CogapsParams()
params &lt;- setFixedPatterns(params, consensusMatrix, &#39;P&#39;)
GWCoGAPS(GISTCsvPath, params, explicitSets=getSubsets(result))
</code></pre>

<pre><code>## Warning in GWCoGAPS(GISTCsvPath, params, explicitSets =
## getSubsets(result)): GWCoGAPS is deprecated, use the main function CoGAPS
## with the argument: distributed=&quot;genome-wide&quot;
</code></pre>

<pre><code>## 
## This is CoGAPS version 3.5.3 
## Running genome-wide CoGAPS on /tmp/RtmpFzxeSf/Rinst48274876303f/CoGAPS/extdata/GIST.csv (1363 genes and 9 samples) with parameters:
## 
## -- Standard Parameters --
## nPatterns            7 
## nIterations          2000 
## seed                 671 
## singleCell           FALSE 
## sparseOptimization   FALSE 
## distributed          genome-wide 
## 
## -- Sparsity Parameters --
## alpha          0.01 
## maxGibbsMass   100 
## 
## -- Distributed CoGAPS Parameters -- 
## nSets          4 
## cut            7 
## minNS          2 
## maxNS          6 
## 
## Creating subsets...using provided named subsets
## set sizes (min, mean, max): (340, 340.75, 343)
## Running Final Stage...
</code></pre>

<pre><code>## [1] &quot;CogapsResult object with 1363 features and 9 samples&quot;
## [1] &quot;7 patterns were learned&quot;
</code></pre>

<h1>sessionInfo()</h1>

<pre><code class="r">sessionInfo()
</code></pre>

<pre><code>## R version 3.6.0 (2019-04-26)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 18.04.2 LTS
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=C              
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] BiocParallel_1.18.0 CoGAPS_3.5.3       
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.1                  highr_0.8                  
##  [3] compiler_3.6.0              RColorBrewer_1.1-2         
##  [5] BiocManager_1.30.4          GenomeInfoDb_1.20.0        
##  [7] XVector_0.24.0              bitops_1.0-6               
##  [9] tools_3.6.0                 zlibbioc_1.30.0            
## [11] SingleCellExperiment_1.6.0  digest_0.6.19              
## [13] rhdf5_2.28.0                evaluate_0.14              
## [15] lattice_0.20-38             Matrix_1.2-17              
## [17] DelayedArray_0.10.0         yaml_2.2.0                 
## [19] parallel_3.6.0              xfun_0.8                   
## [21] GenomeInfoDbData_1.2.1      stringr_1.4.0              
## [23] knitr_1.23                  cluster_2.0.9              
## [25] caTools_1.17.1.2            S4Vectors_0.22.0           
## [27] gtools_3.8.1                IRanges_2.18.1             
## [29] stats4_3.6.0                grid_3.6.0                 
## [31] Biobase_2.44.0              rmarkdown_1.13             
## [33] gdata_2.18.0                Rhdf5lib_1.6.0             
## [35] magrittr_1.5                gplots_3.0.1.1             
## [37] htmltools_0.3.6             matrixStats_0.54.0         
## [39] BiocGenerics_0.30.0         GenomicRanges_1.36.0       
## [41] SummarizedExperiment_1.14.0 BiocStyle_2.12.0           
## [43] KernSmooth_2.23-15          stringi_1.4.3              
## [45] RCurl_1.95-4.12
</code></pre>

<h1>Citing CoGAPS</h1>

<p>If you use the CoGAPS package for your analysis, please cite @FERTIG_2010</p>

<p>If you use the gene set statistic, please cite @OCHS_2009</p>

<h1>References</h1>

</body>

</html>
